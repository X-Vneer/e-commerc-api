
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ProductSize` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model ProductSize
 * 
 */
export type ProductSizeModel = runtime.Types.Result.DefaultSelection<Prisma.$ProductSizePayload>

export type AggregateProductSize = {
  _count: ProductSizeCountAggregateOutputType | null
  _avg: ProductSizeAvgAggregateOutputType | null
  _sum: ProductSizeSumAggregateOutputType | null
  _min: ProductSizeMinAggregateOutputType | null
  _max: ProductSizeMaxAggregateOutputType | null
}

export type ProductSizeAvgAggregateOutputType = {
  id: number | null
  color_id: number | null
  hip: number | null
  chest: number | null
}

export type ProductSizeSumAggregateOutputType = {
  id: number | null
  color_id: number | null
  hip: number | null
  chest: number | null
}

export type ProductSizeMinAggregateOutputType = {
  id: number | null
  color_id: number | null
  size_code: string | null
  hip: number | null
  chest: number | null
}

export type ProductSizeMaxAggregateOutputType = {
  id: number | null
  color_id: number | null
  size_code: string | null
  hip: number | null
  chest: number | null
}

export type ProductSizeCountAggregateOutputType = {
  id: number
  color_id: number
  size_code: number
  hip: number
  chest: number
  _all: number
}


export type ProductSizeAvgAggregateInputType = {
  id?: true
  color_id?: true
  hip?: true
  chest?: true
}

export type ProductSizeSumAggregateInputType = {
  id?: true
  color_id?: true
  hip?: true
  chest?: true
}

export type ProductSizeMinAggregateInputType = {
  id?: true
  color_id?: true
  size_code?: true
  hip?: true
  chest?: true
}

export type ProductSizeMaxAggregateInputType = {
  id?: true
  color_id?: true
  size_code?: true
  hip?: true
  chest?: true
}

export type ProductSizeCountAggregateInputType = {
  id?: true
  color_id?: true
  size_code?: true
  hip?: true
  chest?: true
  _all?: true
}

export type ProductSizeAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductSize to aggregate.
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductSizes to fetch.
   */
  orderBy?: Prisma.ProductSizeOrderByWithRelationInput | Prisma.ProductSizeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProductSizeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductSizes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductSizes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ProductSizes
  **/
  _count?: true | ProductSizeCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ProductSizeAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ProductSizeSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProductSizeMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProductSizeMaxAggregateInputType
}

export type GetProductSizeAggregateType<T extends ProductSizeAggregateArgs> = {
      [P in keyof T & keyof AggregateProductSize]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProductSize[P]>
    : Prisma.GetScalarType<T[P], AggregateProductSize[P]>
}




export type ProductSizeGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProductSizeWhereInput
  orderBy?: Prisma.ProductSizeOrderByWithAggregationInput | Prisma.ProductSizeOrderByWithAggregationInput[]
  by: Prisma.ProductSizeScalarFieldEnum[] | Prisma.ProductSizeScalarFieldEnum
  having?: Prisma.ProductSizeScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProductSizeCountAggregateInputType | true
  _avg?: ProductSizeAvgAggregateInputType
  _sum?: ProductSizeSumAggregateInputType
  _min?: ProductSizeMinAggregateInputType
  _max?: ProductSizeMaxAggregateInputType
}

export type ProductSizeGroupByOutputType = {
  id: number
  color_id: number
  size_code: string
  hip: number
  chest: number
  _count: ProductSizeCountAggregateOutputType | null
  _avg: ProductSizeAvgAggregateOutputType | null
  _sum: ProductSizeSumAggregateOutputType | null
  _min: ProductSizeMinAggregateOutputType | null
  _max: ProductSizeMaxAggregateOutputType | null
}

type GetProductSizeGroupByPayload<T extends ProductSizeGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProductSizeGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProductSizeGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
      }
    >
  >



export type ProductSizeWhereInput = {
  AND?: Prisma.ProductSizeWhereInput | Prisma.ProductSizeWhereInput[]
  OR?: Prisma.ProductSizeWhereInput[]
  NOT?: Prisma.ProductSizeWhereInput | Prisma.ProductSizeWhereInput[]
  id?: Prisma.IntFilter<"ProductSize"> | number
  color_id?: Prisma.IntFilter<"ProductSize"> | number
  size_code?: Prisma.StringFilter<"ProductSize"> | string
  hip?: Prisma.FloatFilter<"ProductSize"> | number
  chest?: Prisma.FloatFilter<"ProductSize"> | number
  color?: Prisma.XOR<Prisma.ColorScalarRelationFilter, Prisma.ColorWhereInput>
  size?: Prisma.XOR<Prisma.SizeScalarRelationFilter, Prisma.SizeWhereInput>
  inventories?: Prisma.ProductInventoryListRelationFilter
  cartItems?: Prisma.CartItemListRelationFilter
}

export type ProductSizeOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  size_code?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
  color?: Prisma.ColorOrderByWithRelationInput
  size?: Prisma.SizeOrderByWithRelationInput
  inventories?: Prisma.ProductInventoryOrderByRelationAggregateInput
  cartItems?: Prisma.CartItemOrderByRelationAggregateInput
}

export type ProductSizeWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  size_code_color_id?: Prisma.ProductSizeSize_codeColor_idCompoundUniqueInput
  AND?: Prisma.ProductSizeWhereInput | Prisma.ProductSizeWhereInput[]
  OR?: Prisma.ProductSizeWhereInput[]
  NOT?: Prisma.ProductSizeWhereInput | Prisma.ProductSizeWhereInput[]
  color_id?: Prisma.IntFilter<"ProductSize"> | number
  size_code?: Prisma.StringFilter<"ProductSize"> | string
  hip?: Prisma.FloatFilter<"ProductSize"> | number
  chest?: Prisma.FloatFilter<"ProductSize"> | number
  color?: Prisma.XOR<Prisma.ColorScalarRelationFilter, Prisma.ColorWhereInput>
  size?: Prisma.XOR<Prisma.SizeScalarRelationFilter, Prisma.SizeWhereInput>
  inventories?: Prisma.ProductInventoryListRelationFilter
  cartItems?: Prisma.CartItemListRelationFilter
}, "id" | "size_code_color_id">

export type ProductSizeOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  size_code?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
  _count?: Prisma.ProductSizeCountOrderByAggregateInput
  _avg?: Prisma.ProductSizeAvgOrderByAggregateInput
  _max?: Prisma.ProductSizeMaxOrderByAggregateInput
  _min?: Prisma.ProductSizeMinOrderByAggregateInput
  _sum?: Prisma.ProductSizeSumOrderByAggregateInput
}

export type ProductSizeScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProductSizeScalarWhereWithAggregatesInput | Prisma.ProductSizeScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProductSizeScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProductSizeScalarWhereWithAggregatesInput | Prisma.ProductSizeScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"ProductSize"> | number
  color_id?: Prisma.IntWithAggregatesFilter<"ProductSize"> | number
  size_code?: Prisma.StringWithAggregatesFilter<"ProductSize"> | string
  hip?: Prisma.FloatWithAggregatesFilter<"ProductSize"> | number
  chest?: Prisma.FloatWithAggregatesFilter<"ProductSize"> | number
}

export type ProductSizeCreateInput = {
  hip: number
  chest: number
  color: Prisma.ColorCreateNestedOneWithoutSizesInput
  size: Prisma.SizeCreateNestedOneWithoutProduct_sizesInput
  inventories?: Prisma.ProductInventoryCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemCreateNestedManyWithoutSizeInput
}

export type ProductSizeUncheckedCreateInput = {
  id?: number
  color_id: number
  size_code: string
  hip: number
  chest: number
  inventories?: Prisma.ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemUncheckedCreateNestedManyWithoutSizeInput
}

export type ProductSizeUpdateInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  color?: Prisma.ColorUpdateOneRequiredWithoutSizesNestedInput
  size?: Prisma.SizeUpdateOneRequiredWithoutProduct_sizesNestedInput
  inventories?: Prisma.ProductInventoryUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  inventories?: Prisma.ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUncheckedUpdateManyWithoutSizeNestedInput
}

export type ProductSizeCreateManyInput = {
  id?: number
  color_id: number
  size_code: string
  hip: number
  chest: number
}

export type ProductSizeUpdateManyMutationInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type ProductSizeUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type ProductSizeScalarRelationFilter = {
  is?: Prisma.ProductSizeWhereInput
  isNot?: Prisma.ProductSizeWhereInput
}

export type ProductSizeListRelationFilter = {
  every?: Prisma.ProductSizeWhereInput
  some?: Prisma.ProductSizeWhereInput
  none?: Prisma.ProductSizeWhereInput
}

export type ProductSizeOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProductSizeSize_codeColor_idCompoundUniqueInput = {
  size_code: string
  color_id: number
}

export type ProductSizeCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  size_code?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
}

export type ProductSizeAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
}

export type ProductSizeMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  size_code?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
}

export type ProductSizeMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  size_code?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
}

export type ProductSizeSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  color_id?: Prisma.SortOrder
  hip?: Prisma.SortOrder
  chest?: Prisma.SortOrder
}

export type ProductSizeCreateNestedOneWithoutInventoriesInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutInventoriesInput, Prisma.ProductSizeUncheckedCreateWithoutInventoriesInput>
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutInventoriesInput
  connect?: Prisma.ProductSizeWhereUniqueInput
}

export type ProductSizeUpdateOneRequiredWithoutInventoriesNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutInventoriesInput, Prisma.ProductSizeUncheckedCreateWithoutInventoriesInput>
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutInventoriesInput
  upsert?: Prisma.ProductSizeUpsertWithoutInventoriesInput
  connect?: Prisma.ProductSizeWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ProductSizeUpdateToOneWithWhereWithoutInventoriesInput, Prisma.ProductSizeUpdateWithoutInventoriesInput>, Prisma.ProductSizeUncheckedUpdateWithoutInventoriesInput>
}

export type ProductSizeCreateNestedManyWithoutColorInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput> | Prisma.ProductSizeCreateWithoutColorInput[] | Prisma.ProductSizeUncheckedCreateWithoutColorInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutColorInput | Prisma.ProductSizeCreateOrConnectWithoutColorInput[]
  createMany?: Prisma.ProductSizeCreateManyColorInputEnvelope
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
}

export type ProductSizeUncheckedCreateNestedManyWithoutColorInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput> | Prisma.ProductSizeCreateWithoutColorInput[] | Prisma.ProductSizeUncheckedCreateWithoutColorInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutColorInput | Prisma.ProductSizeCreateOrConnectWithoutColorInput[]
  createMany?: Prisma.ProductSizeCreateManyColorInputEnvelope
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
}

export type ProductSizeUpdateManyWithoutColorNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput> | Prisma.ProductSizeCreateWithoutColorInput[] | Prisma.ProductSizeUncheckedCreateWithoutColorInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutColorInput | Prisma.ProductSizeCreateOrConnectWithoutColorInput[]
  upsert?: Prisma.ProductSizeUpsertWithWhereUniqueWithoutColorInput | Prisma.ProductSizeUpsertWithWhereUniqueWithoutColorInput[]
  createMany?: Prisma.ProductSizeCreateManyColorInputEnvelope
  set?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  disconnect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  delete?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  update?: Prisma.ProductSizeUpdateWithWhereUniqueWithoutColorInput | Prisma.ProductSizeUpdateWithWhereUniqueWithoutColorInput[]
  updateMany?: Prisma.ProductSizeUpdateManyWithWhereWithoutColorInput | Prisma.ProductSizeUpdateManyWithWhereWithoutColorInput[]
  deleteMany?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
}

export type ProductSizeUncheckedUpdateManyWithoutColorNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput> | Prisma.ProductSizeCreateWithoutColorInput[] | Prisma.ProductSizeUncheckedCreateWithoutColorInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutColorInput | Prisma.ProductSizeCreateOrConnectWithoutColorInput[]
  upsert?: Prisma.ProductSizeUpsertWithWhereUniqueWithoutColorInput | Prisma.ProductSizeUpsertWithWhereUniqueWithoutColorInput[]
  createMany?: Prisma.ProductSizeCreateManyColorInputEnvelope
  set?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  disconnect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  delete?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  update?: Prisma.ProductSizeUpdateWithWhereUniqueWithoutColorInput | Prisma.ProductSizeUpdateWithWhereUniqueWithoutColorInput[]
  updateMany?: Prisma.ProductSizeUpdateManyWithWhereWithoutColorInput | Prisma.ProductSizeUpdateManyWithWhereWithoutColorInput[]
  deleteMany?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
}

export type ProductSizeCreateNestedManyWithoutSizeInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput> | Prisma.ProductSizeCreateWithoutSizeInput[] | Prisma.ProductSizeUncheckedCreateWithoutSizeInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutSizeInput | Prisma.ProductSizeCreateOrConnectWithoutSizeInput[]
  createMany?: Prisma.ProductSizeCreateManySizeInputEnvelope
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
}

export type ProductSizeUncheckedCreateNestedManyWithoutSizeInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput> | Prisma.ProductSizeCreateWithoutSizeInput[] | Prisma.ProductSizeUncheckedCreateWithoutSizeInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutSizeInput | Prisma.ProductSizeCreateOrConnectWithoutSizeInput[]
  createMany?: Prisma.ProductSizeCreateManySizeInputEnvelope
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
}

export type ProductSizeUpdateManyWithoutSizeNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput> | Prisma.ProductSizeCreateWithoutSizeInput[] | Prisma.ProductSizeUncheckedCreateWithoutSizeInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutSizeInput | Prisma.ProductSizeCreateOrConnectWithoutSizeInput[]
  upsert?: Prisma.ProductSizeUpsertWithWhereUniqueWithoutSizeInput | Prisma.ProductSizeUpsertWithWhereUniqueWithoutSizeInput[]
  createMany?: Prisma.ProductSizeCreateManySizeInputEnvelope
  set?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  disconnect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  delete?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  update?: Prisma.ProductSizeUpdateWithWhereUniqueWithoutSizeInput | Prisma.ProductSizeUpdateWithWhereUniqueWithoutSizeInput[]
  updateMany?: Prisma.ProductSizeUpdateManyWithWhereWithoutSizeInput | Prisma.ProductSizeUpdateManyWithWhereWithoutSizeInput[]
  deleteMany?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
}

export type ProductSizeUncheckedUpdateManyWithoutSizeNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput> | Prisma.ProductSizeCreateWithoutSizeInput[] | Prisma.ProductSizeUncheckedCreateWithoutSizeInput[]
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutSizeInput | Prisma.ProductSizeCreateOrConnectWithoutSizeInput[]
  upsert?: Prisma.ProductSizeUpsertWithWhereUniqueWithoutSizeInput | Prisma.ProductSizeUpsertWithWhereUniqueWithoutSizeInput[]
  createMany?: Prisma.ProductSizeCreateManySizeInputEnvelope
  set?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  disconnect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  delete?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  connect?: Prisma.ProductSizeWhereUniqueInput | Prisma.ProductSizeWhereUniqueInput[]
  update?: Prisma.ProductSizeUpdateWithWhereUniqueWithoutSizeInput | Prisma.ProductSizeUpdateWithWhereUniqueWithoutSizeInput[]
  updateMany?: Prisma.ProductSizeUpdateManyWithWhereWithoutSizeInput | Prisma.ProductSizeUpdateManyWithWhereWithoutSizeInput[]
  deleteMany?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
}

export type ProductSizeCreateNestedOneWithoutCartItemsInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutCartItemsInput, Prisma.ProductSizeUncheckedCreateWithoutCartItemsInput>
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutCartItemsInput
  connect?: Prisma.ProductSizeWhereUniqueInput
}

export type ProductSizeUpdateOneRequiredWithoutCartItemsNestedInput = {
  create?: Prisma.XOR<Prisma.ProductSizeCreateWithoutCartItemsInput, Prisma.ProductSizeUncheckedCreateWithoutCartItemsInput>
  connectOrCreate?: Prisma.ProductSizeCreateOrConnectWithoutCartItemsInput
  upsert?: Prisma.ProductSizeUpsertWithoutCartItemsInput
  connect?: Prisma.ProductSizeWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ProductSizeUpdateToOneWithWhereWithoutCartItemsInput, Prisma.ProductSizeUpdateWithoutCartItemsInput>, Prisma.ProductSizeUncheckedUpdateWithoutCartItemsInput>
}

export type ProductSizeCreateWithoutInventoriesInput = {
  hip: number
  chest: number
  color: Prisma.ColorCreateNestedOneWithoutSizesInput
  size: Prisma.SizeCreateNestedOneWithoutProduct_sizesInput
  cartItems?: Prisma.CartItemCreateNestedManyWithoutSizeInput
}

export type ProductSizeUncheckedCreateWithoutInventoriesInput = {
  id?: number
  color_id: number
  size_code: string
  hip: number
  chest: number
  cartItems?: Prisma.CartItemUncheckedCreateNestedManyWithoutSizeInput
}

export type ProductSizeCreateOrConnectWithoutInventoriesInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutInventoriesInput, Prisma.ProductSizeUncheckedCreateWithoutInventoriesInput>
}

export type ProductSizeUpsertWithoutInventoriesInput = {
  update: Prisma.XOR<Prisma.ProductSizeUpdateWithoutInventoriesInput, Prisma.ProductSizeUncheckedUpdateWithoutInventoriesInput>
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutInventoriesInput, Prisma.ProductSizeUncheckedCreateWithoutInventoriesInput>
  where?: Prisma.ProductSizeWhereInput
}

export type ProductSizeUpdateToOneWithWhereWithoutInventoriesInput = {
  where?: Prisma.ProductSizeWhereInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateWithoutInventoriesInput, Prisma.ProductSizeUncheckedUpdateWithoutInventoriesInput>
}

export type ProductSizeUpdateWithoutInventoriesInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  color?: Prisma.ColorUpdateOneRequiredWithoutSizesNestedInput
  size?: Prisma.SizeUpdateOneRequiredWithoutProduct_sizesNestedInput
  cartItems?: Prisma.CartItemUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateWithoutInventoriesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  cartItems?: Prisma.CartItemUncheckedUpdateManyWithoutSizeNestedInput
}

export type ProductSizeCreateWithoutColorInput = {
  hip: number
  chest: number
  size: Prisma.SizeCreateNestedOneWithoutProduct_sizesInput
  inventories?: Prisma.ProductInventoryCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemCreateNestedManyWithoutSizeInput
}

export type ProductSizeUncheckedCreateWithoutColorInput = {
  id?: number
  size_code: string
  hip: number
  chest: number
  inventories?: Prisma.ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemUncheckedCreateNestedManyWithoutSizeInput
}

export type ProductSizeCreateOrConnectWithoutColorInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput>
}

export type ProductSizeCreateManyColorInputEnvelope = {
  data: Prisma.ProductSizeCreateManyColorInput | Prisma.ProductSizeCreateManyColorInput[]
  skipDuplicates?: boolean
}

export type ProductSizeUpsertWithWhereUniqueWithoutColorInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductSizeUpdateWithoutColorInput, Prisma.ProductSizeUncheckedUpdateWithoutColorInput>
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutColorInput, Prisma.ProductSizeUncheckedCreateWithoutColorInput>
}

export type ProductSizeUpdateWithWhereUniqueWithoutColorInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateWithoutColorInput, Prisma.ProductSizeUncheckedUpdateWithoutColorInput>
}

export type ProductSizeUpdateManyWithWhereWithoutColorInput = {
  where: Prisma.ProductSizeScalarWhereInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateManyMutationInput, Prisma.ProductSizeUncheckedUpdateManyWithoutColorInput>
}

export type ProductSizeScalarWhereInput = {
  AND?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
  OR?: Prisma.ProductSizeScalarWhereInput[]
  NOT?: Prisma.ProductSizeScalarWhereInput | Prisma.ProductSizeScalarWhereInput[]
  id?: Prisma.IntFilter<"ProductSize"> | number
  color_id?: Prisma.IntFilter<"ProductSize"> | number
  size_code?: Prisma.StringFilter<"ProductSize"> | string
  hip?: Prisma.FloatFilter<"ProductSize"> | number
  chest?: Prisma.FloatFilter<"ProductSize"> | number
}

export type ProductSizeCreateWithoutSizeInput = {
  hip: number
  chest: number
  color: Prisma.ColorCreateNestedOneWithoutSizesInput
  inventories?: Prisma.ProductInventoryCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemCreateNestedManyWithoutSizeInput
}

export type ProductSizeUncheckedCreateWithoutSizeInput = {
  id?: number
  color_id: number
  hip: number
  chest: number
  inventories?: Prisma.ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
  cartItems?: Prisma.CartItemUncheckedCreateNestedManyWithoutSizeInput
}

export type ProductSizeCreateOrConnectWithoutSizeInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput>
}

export type ProductSizeCreateManySizeInputEnvelope = {
  data: Prisma.ProductSizeCreateManySizeInput | Prisma.ProductSizeCreateManySizeInput[]
  skipDuplicates?: boolean
}

export type ProductSizeUpsertWithWhereUniqueWithoutSizeInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  update: Prisma.XOR<Prisma.ProductSizeUpdateWithoutSizeInput, Prisma.ProductSizeUncheckedUpdateWithoutSizeInput>
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutSizeInput, Prisma.ProductSizeUncheckedCreateWithoutSizeInput>
}

export type ProductSizeUpdateWithWhereUniqueWithoutSizeInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateWithoutSizeInput, Prisma.ProductSizeUncheckedUpdateWithoutSizeInput>
}

export type ProductSizeUpdateManyWithWhereWithoutSizeInput = {
  where: Prisma.ProductSizeScalarWhereInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateManyMutationInput, Prisma.ProductSizeUncheckedUpdateManyWithoutSizeInput>
}

export type ProductSizeCreateWithoutCartItemsInput = {
  hip: number
  chest: number
  color: Prisma.ColorCreateNestedOneWithoutSizesInput
  size: Prisma.SizeCreateNestedOneWithoutProduct_sizesInput
  inventories?: Prisma.ProductInventoryCreateNestedManyWithoutProductSizeInput
}

export type ProductSizeUncheckedCreateWithoutCartItemsInput = {
  id?: number
  color_id: number
  size_code: string
  hip: number
  chest: number
  inventories?: Prisma.ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
}

export type ProductSizeCreateOrConnectWithoutCartItemsInput = {
  where: Prisma.ProductSizeWhereUniqueInput
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutCartItemsInput, Prisma.ProductSizeUncheckedCreateWithoutCartItemsInput>
}

export type ProductSizeUpsertWithoutCartItemsInput = {
  update: Prisma.XOR<Prisma.ProductSizeUpdateWithoutCartItemsInput, Prisma.ProductSizeUncheckedUpdateWithoutCartItemsInput>
  create: Prisma.XOR<Prisma.ProductSizeCreateWithoutCartItemsInput, Prisma.ProductSizeUncheckedCreateWithoutCartItemsInput>
  where?: Prisma.ProductSizeWhereInput
}

export type ProductSizeUpdateToOneWithWhereWithoutCartItemsInput = {
  where?: Prisma.ProductSizeWhereInput
  data: Prisma.XOR<Prisma.ProductSizeUpdateWithoutCartItemsInput, Prisma.ProductSizeUncheckedUpdateWithoutCartItemsInput>
}

export type ProductSizeUpdateWithoutCartItemsInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  color?: Prisma.ColorUpdateOneRequiredWithoutSizesNestedInput
  size?: Prisma.SizeUpdateOneRequiredWithoutProduct_sizesNestedInput
  inventories?: Prisma.ProductInventoryUpdateManyWithoutProductSizeNestedInput
}

export type ProductSizeUncheckedUpdateWithoutCartItemsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  inventories?: Prisma.ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
}

export type ProductSizeCreateManyColorInput = {
  id?: number
  size_code: string
  hip: number
  chest: number
}

export type ProductSizeUpdateWithoutColorInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  size?: Prisma.SizeUpdateOneRequiredWithoutProduct_sizesNestedInput
  inventories?: Prisma.ProductInventoryUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateWithoutColorInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  inventories?: Prisma.ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUncheckedUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateManyWithoutColorInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  size_code?: Prisma.StringFieldUpdateOperationsInput | string
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type ProductSizeCreateManySizeInput = {
  id?: number
  color_id: number
  hip: number
  chest: number
}

export type ProductSizeUpdateWithoutSizeInput = {
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  color?: Prisma.ColorUpdateOneRequiredWithoutSizesNestedInput
  inventories?: Prisma.ProductInventoryUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateWithoutSizeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
  inventories?: Prisma.ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
  cartItems?: Prisma.CartItemUncheckedUpdateManyWithoutSizeNestedInput
}

export type ProductSizeUncheckedUpdateManyWithoutSizeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  color_id?: Prisma.IntFieldUpdateOperationsInput | number
  hip?: Prisma.FloatFieldUpdateOperationsInput | number
  chest?: Prisma.FloatFieldUpdateOperationsInput | number
}


/**
 * Count Type ProductSizeCountOutputType
 */

export type ProductSizeCountOutputType = {
  inventories: number
  cartItems: number
}

export type ProductSizeCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  inventories?: boolean | ProductSizeCountOutputTypeCountInventoriesArgs
  cartItems?: boolean | ProductSizeCountOutputTypeCountCartItemsArgs
}

/**
 * ProductSizeCountOutputType without action
 */
export type ProductSizeCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSizeCountOutputType
   */
  select?: Prisma.ProductSizeCountOutputTypeSelect<ExtArgs> | null
}

/**
 * ProductSizeCountOutputType without action
 */
export type ProductSizeCountOutputTypeCountInventoriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProductInventoryWhereInput
}

/**
 * ProductSizeCountOutputType without action
 */
export type ProductSizeCountOutputTypeCountCartItemsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CartItemWhereInput
}


export type ProductSizeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  color_id?: boolean
  size_code?: boolean
  hip?: boolean
  chest?: boolean
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
  inventories?: boolean | Prisma.ProductSize$inventoriesArgs<ExtArgs>
  cartItems?: boolean | Prisma.ProductSize$cartItemsArgs<ExtArgs>
  _count?: boolean | Prisma.ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productSize"]>

export type ProductSizeSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  color_id?: boolean
  size_code?: boolean
  hip?: boolean
  chest?: boolean
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productSize"]>

export type ProductSizeSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  color_id?: boolean
  size_code?: boolean
  hip?: boolean
  chest?: boolean
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["productSize"]>

export type ProductSizeSelectScalar = {
  id?: boolean
  color_id?: boolean
  size_code?: boolean
  hip?: boolean
  chest?: boolean
}

export type ProductSizeOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "color_id" | "size_code" | "hip" | "chest", ExtArgs["result"]["productSize"]>
export type ProductSizeInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
  inventories?: boolean | Prisma.ProductSize$inventoriesArgs<ExtArgs>
  cartItems?: boolean | Prisma.ProductSize$cartItemsArgs<ExtArgs>
  _count?: boolean | Prisma.ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
}
export type ProductSizeIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
}
export type ProductSizeIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  color?: boolean | Prisma.ColorDefaultArgs<ExtArgs>
  size?: boolean | Prisma.SizeDefaultArgs<ExtArgs>
}

export type $ProductSizePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ProductSize"
  objects: {
    color: Prisma.$ColorPayload<ExtArgs>
    size: Prisma.$SizePayload<ExtArgs>
    inventories: Prisma.$ProductInventoryPayload<ExtArgs>[]
    cartItems: Prisma.$CartItemPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    color_id: number
    size_code: string
    hip: number
    chest: number
  }, ExtArgs["result"]["productSize"]>
  composites: {}
}

export type ProductSizeGetPayload<S extends boolean | null | undefined | ProductSizeDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProductSizePayload, S>

export type ProductSizeCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProductSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProductSizeCountAggregateInputType | true
  }

export interface ProductSizeDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSize'], meta: { name: 'ProductSize' } }
  /**
   * Find zero or one ProductSize that matches the filter.
   * @param {ProductSizeFindUniqueArgs} args - Arguments to find a ProductSize
   * @example
   * // Get one ProductSize
   * const productSize = await prisma.productSize.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProductSizeFindUniqueArgs>(args: Prisma.SelectSubset<T, ProductSizeFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ProductSize that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProductSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductSize
   * @example
   * // Get one ProductSize
   * const productSize = await prisma.productSize.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProductSizeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProductSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductSize that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeFindFirstArgs} args - Arguments to find a ProductSize
   * @example
   * // Get one ProductSize
   * const productSize = await prisma.productSize.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProductSizeFindFirstArgs>(args?: Prisma.SelectSubset<T, ProductSizeFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProductSize that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeFindFirstOrThrowArgs} args - Arguments to find a ProductSize
   * @example
   * // Get one ProductSize
   * const productSize = await prisma.productSize.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProductSizeFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProductSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ProductSizes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ProductSizes
   * const productSizes = await prisma.productSize.findMany()
   * 
   * // Get first 10 ProductSizes
   * const productSizes = await prisma.productSize.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const productSizeWithIdOnly = await prisma.productSize.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ProductSizeFindManyArgs>(args?: Prisma.SelectSubset<T, ProductSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ProductSize.
   * @param {ProductSizeCreateArgs} args - Arguments to create a ProductSize.
   * @example
   * // Create one ProductSize
   * const ProductSize = await prisma.productSize.create({
   *   data: {
   *     // ... data to create a ProductSize
   *   }
   * })
   * 
   */
  create<T extends ProductSizeCreateArgs>(args: Prisma.SelectSubset<T, ProductSizeCreateArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ProductSizes.
   * @param {ProductSizeCreateManyArgs} args - Arguments to create many ProductSizes.
   * @example
   * // Create many ProductSizes
   * const productSize = await prisma.productSize.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProductSizeCreateManyArgs>(args?: Prisma.SelectSubset<T, ProductSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ProductSizes and returns the data saved in the database.
   * @param {ProductSizeCreateManyAndReturnArgs} args - Arguments to create many ProductSizes.
   * @example
   * // Create many ProductSizes
   * const productSize = await prisma.productSize.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ProductSizes and only return the `id`
   * const productSizeWithIdOnly = await prisma.productSize.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProductSizeCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProductSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ProductSize.
   * @param {ProductSizeDeleteArgs} args - Arguments to delete one ProductSize.
   * @example
   * // Delete one ProductSize
   * const ProductSize = await prisma.productSize.delete({
   *   where: {
   *     // ... filter to delete one ProductSize
   *   }
   * })
   * 
   */
  delete<T extends ProductSizeDeleteArgs>(args: Prisma.SelectSubset<T, ProductSizeDeleteArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ProductSize.
   * @param {ProductSizeUpdateArgs} args - Arguments to update one ProductSize.
   * @example
   * // Update one ProductSize
   * const productSize = await prisma.productSize.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProductSizeUpdateArgs>(args: Prisma.SelectSubset<T, ProductSizeUpdateArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ProductSizes.
   * @param {ProductSizeDeleteManyArgs} args - Arguments to filter ProductSizes to delete.
   * @example
   * // Delete a few ProductSizes
   * const { count } = await prisma.productSize.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProductSizeDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProductSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductSizes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ProductSizes
   * const productSize = await prisma.productSize.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProductSizeUpdateManyArgs>(args: Prisma.SelectSubset<T, ProductSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProductSizes and returns the data updated in the database.
   * @param {ProductSizeUpdateManyAndReturnArgs} args - Arguments to update many ProductSizes.
   * @example
   * // Update many ProductSizes
   * const productSize = await prisma.productSize.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ProductSizes and only return the `id`
   * const productSizeWithIdOnly = await prisma.productSize.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProductSizeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProductSizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ProductSize.
   * @param {ProductSizeUpsertArgs} args - Arguments to update or create a ProductSize.
   * @example
   * // Update or create a ProductSize
   * const productSize = await prisma.productSize.upsert({
   *   create: {
   *     // ... data to create a ProductSize
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ProductSize we want to update
   *   }
   * })
   */
  upsert<T extends ProductSizeUpsertArgs>(args: Prisma.SelectSubset<T, ProductSizeUpsertArgs<ExtArgs>>): Prisma.Prisma__ProductSizeClient<runtime.Types.Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ProductSizes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeCountArgs} args - Arguments to filter ProductSizes to count.
   * @example
   * // Count the number of ProductSizes
   * const count = await prisma.productSize.count({
   *   where: {
   *     // ... the filter for the ProductSizes we want to count
   *   }
   * })
  **/
  count<T extends ProductSizeCountArgs>(
    args?: Prisma.Subset<T, ProductSizeCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProductSizeCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ProductSize.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProductSizeAggregateArgs>(args: Prisma.Subset<T, ProductSizeAggregateArgs>): Prisma.PrismaPromise<GetProductSizeAggregateType<T>>

  /**
   * Group by ProductSize.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProductSizeGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProductSizeGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProductSizeGroupByArgs['orderBy'] }
      : { orderBy?: ProductSizeGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProductSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ProductSize model
 */
readonly fields: ProductSizeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ProductSize.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProductSizeClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  color<T extends Prisma.ColorDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ColorDefaultArgs<ExtArgs>>): Prisma.Prisma__ColorClient<runtime.Types.Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  size<T extends Prisma.SizeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.SizeDefaultArgs<ExtArgs>>): Prisma.Prisma__SizeClient<runtime.Types.Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  inventories<T extends Prisma.ProductSize$inventoriesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductSize$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  cartItems<T extends Prisma.ProductSize$cartItemsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductSize$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ProductSize model
 */
export interface ProductSizeFieldRefs {
  readonly id: Prisma.FieldRef<"ProductSize", 'Int'>
  readonly color_id: Prisma.FieldRef<"ProductSize", 'Int'>
  readonly size_code: Prisma.FieldRef<"ProductSize", 'String'>
  readonly hip: Prisma.FieldRef<"ProductSize", 'Float'>
  readonly chest: Prisma.FieldRef<"ProductSize", 'Float'>
}
    

// Custom InputTypes
/**
 * ProductSize findUnique
 */
export type ProductSizeFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter, which ProductSize to fetch.
   */
  where: Prisma.ProductSizeWhereUniqueInput
}

/**
 * ProductSize findUniqueOrThrow
 */
export type ProductSizeFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter, which ProductSize to fetch.
   */
  where: Prisma.ProductSizeWhereUniqueInput
}

/**
 * ProductSize findFirst
 */
export type ProductSizeFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter, which ProductSize to fetch.
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductSizes to fetch.
   */
  orderBy?: Prisma.ProductSizeOrderByWithRelationInput | Prisma.ProductSizeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductSizes.
   */
  cursor?: Prisma.ProductSizeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductSizes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductSizes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductSizes.
   */
  distinct?: Prisma.ProductSizeScalarFieldEnum | Prisma.ProductSizeScalarFieldEnum[]
}

/**
 * ProductSize findFirstOrThrow
 */
export type ProductSizeFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter, which ProductSize to fetch.
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductSizes to fetch.
   */
  orderBy?: Prisma.ProductSizeOrderByWithRelationInput | Prisma.ProductSizeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProductSizes.
   */
  cursor?: Prisma.ProductSizeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductSizes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductSizes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProductSizes.
   */
  distinct?: Prisma.ProductSizeScalarFieldEnum | Prisma.ProductSizeScalarFieldEnum[]
}

/**
 * ProductSize findMany
 */
export type ProductSizeFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter, which ProductSizes to fetch.
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProductSizes to fetch.
   */
  orderBy?: Prisma.ProductSizeOrderByWithRelationInput | Prisma.ProductSizeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ProductSizes.
   */
  cursor?: Prisma.ProductSizeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProductSizes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProductSizes.
   */
  skip?: number
  distinct?: Prisma.ProductSizeScalarFieldEnum | Prisma.ProductSizeScalarFieldEnum[]
}

/**
 * ProductSize create
 */
export type ProductSizeCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * The data needed to create a ProductSize.
   */
  data: Prisma.XOR<Prisma.ProductSizeCreateInput, Prisma.ProductSizeUncheckedCreateInput>
}

/**
 * ProductSize createMany
 */
export type ProductSizeCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ProductSizes.
   */
  data: Prisma.ProductSizeCreateManyInput | Prisma.ProductSizeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ProductSize createManyAndReturn
 */
export type ProductSizeCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * The data used to create many ProductSizes.
   */
  data: Prisma.ProductSizeCreateManyInput | Prisma.ProductSizeCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ProductSize update
 */
export type ProductSizeUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * The data needed to update a ProductSize.
   */
  data: Prisma.XOR<Prisma.ProductSizeUpdateInput, Prisma.ProductSizeUncheckedUpdateInput>
  /**
   * Choose, which ProductSize to update.
   */
  where: Prisma.ProductSizeWhereUniqueInput
}

/**
 * ProductSize updateMany
 */
export type ProductSizeUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ProductSizes.
   */
  data: Prisma.XOR<Prisma.ProductSizeUpdateManyMutationInput, Prisma.ProductSizeUncheckedUpdateManyInput>
  /**
   * Filter which ProductSizes to update
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * Limit how many ProductSizes to update.
   */
  limit?: number
}

/**
 * ProductSize updateManyAndReturn
 */
export type ProductSizeUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * The data used to update ProductSizes.
   */
  data: Prisma.XOR<Prisma.ProductSizeUpdateManyMutationInput, Prisma.ProductSizeUncheckedUpdateManyInput>
  /**
   * Filter which ProductSizes to update
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * Limit how many ProductSizes to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ProductSize upsert
 */
export type ProductSizeUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * The filter to search for the ProductSize to update in case it exists.
   */
  where: Prisma.ProductSizeWhereUniqueInput
  /**
   * In case the ProductSize found by the `where` argument doesn't exist, create a new ProductSize with this data.
   */
  create: Prisma.XOR<Prisma.ProductSizeCreateInput, Prisma.ProductSizeUncheckedCreateInput>
  /**
   * In case the ProductSize was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProductSizeUpdateInput, Prisma.ProductSizeUncheckedUpdateInput>
}

/**
 * ProductSize delete
 */
export type ProductSizeDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
  /**
   * Filter which ProductSize to delete.
   */
  where: Prisma.ProductSizeWhereUniqueInput
}

/**
 * ProductSize deleteMany
 */
export type ProductSizeDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProductSizes to delete
   */
  where?: Prisma.ProductSizeWhereInput
  /**
   * Limit how many ProductSizes to delete.
   */
  limit?: number
}

/**
 * ProductSize.inventories
 */
export type ProductSize$inventoriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductInventory
   */
  select?: Prisma.ProductInventorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductInventory
   */
  omit?: Prisma.ProductInventoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductInventoryInclude<ExtArgs> | null
  where?: Prisma.ProductInventoryWhereInput
  orderBy?: Prisma.ProductInventoryOrderByWithRelationInput | Prisma.ProductInventoryOrderByWithRelationInput[]
  cursor?: Prisma.ProductInventoryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ProductInventoryScalarFieldEnum | Prisma.ProductInventoryScalarFieldEnum[]
}

/**
 * ProductSize.cartItems
 */
export type ProductSize$cartItemsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CartItem
   */
  select?: Prisma.CartItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CartItem
   */
  omit?: Prisma.CartItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CartItemInclude<ExtArgs> | null
  where?: Prisma.CartItemWhereInput
  orderBy?: Prisma.CartItemOrderByWithRelationInput | Prisma.CartItemOrderByWithRelationInput[]
  cursor?: Prisma.CartItemWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CartItemScalarFieldEnum | Prisma.CartItemScalarFieldEnum[]
}

/**
 * ProductSize without action
 */
export type ProductSizeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProductSize
   */
  select?: Prisma.ProductSizeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProductSize
   */
  omit?: Prisma.ProductSizeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProductSizeInclude<ExtArgs> | null
}
